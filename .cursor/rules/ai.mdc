---
description: 
globs: 
alwaysApply: false
---
Modular Development: Keep each agent's code separate and focused on a single responsibility, as you've already done with the Incident Analysis Agent.
Documentation First: Document the purpose, inputs, outputs, and expected behavior of each agent before coding.
Test-Driven Development: Write tests before implementation, like your thorough test coverage for the analyzer.py file.
Dependency Injection: Make dependencies explicit and injectable to facilitate testing and flexibility.
Error Handling: Implement comprehensive error handling with graceful degradation, as you've done in the Incident Agent.
Versioning: Include version information in agent responses to track which model version produced results.
Logging: Maintain detailed logging for debugging and performance tracking.
Configuration Externalization: Keep model parameters and endpoints in configuration files.
2. Code Consistency Improvements
Style Standardization

Implement consistent import ordering (stdlib, third-party, local)
Standardize docstring format (currently mixed styles)
Apply consistent error handling patterns across all modules

Logging Enhancement

Implement structured logging throughout all components
Add log rotation configuration
Create consistent log levels for different types of events

3. Technical Debt Reduction
Remove Deprecated Patterns

Address DeprecationWarning for FastAPI on_event in incident agent (mentioned in your TODOs)
Update httpx client usage to follow current best practices

Configuration Management

Centralize environment variable handling
Create a unified configuration system across components

4. Code Quality Improvements
Error Handling

Implement more robust error handling in MCP's router
Add proper validation for all incoming messages
Create consistent error response formats

Testing Enhancements

Increase test coverage for edge cases
Add performance-focused tests for Redis caching
Implement integration tests between components
Architecture First: Before implementing any significant feature, create or update the appropriate architecture diagrams using Mermaid syntax in the docs/architecture/diagrams/ directory.
Test-Driven Development: Write tests before or alongside feature implementation. Ensure both unit tests and integration tests are created for each new component.
Error Handling: Implement comprehensive error handling for all network calls between services. Use retry mechanisms with exponential backoff for transient failures.
Configuration Management: All configurable values should be retrievable from environment variables with sensible defaults. Document all required environment variables.
Consistent Logging: Include tracking IDs in all log messages for request traceability across services. Use appropriate log levels (INFO for normal operations, WARNING for potential issues, ERROR for failures).
Model Documentation: All Pydantic models should include comprehensive field descriptions and examples using the latest Pydantic v2 syntax.
Docker Compatibility: Ensure all changes are tested in the Docker environment. Pay special attention to inter-service communication, Python imports, and file paths.
API Versioning: All external-facing APIs should include version in the path (e.g., /api/v1/...) to facilitate future non-breaking changes.
Commit Convention: Follow the conventional commit format (feat/fix/docs/etc) with the JIRA ticket number and a concise description.
Code Comments: Add detailed comments for complex logic, particularly for LLM interactions, data transformations, and asynchronous processing.
Timeout Configuration: Explicitly configure timeouts for all inter-service HTTP requests based on expected processing times.
Dependency Documentation: Document all third-party dependencies in requirements.txt with specific versions to ensure reproducible builds.